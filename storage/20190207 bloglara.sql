-- phpMyAdmin SQL Dump
-- version 4.8.3
-- https://www.phpmyadmin.net/
--
-- Хост: localhost
-- Время создания: Фев 07 2019 г., 11:06
-- Версия сервера: 5.7.23-0ubuntu0.16.04.1
-- Версия PHP: 7.2.10-1+ubuntu16.04.1+deb.sury.org+1

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET AUTOCOMMIT = 0;
START TRANSACTION;
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- База данных: `bloglara`
--

-- --------------------------------------------------------

--
-- Структура таблицы `categories`
--

CREATE TABLE `categories` (
  `id` int(10) UNSIGNED NOT NULL,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Дамп данных таблицы `categories`
--

INSERT INTO `categories` (`id`, `name`) VALUES
(1, 'Микроконтроллеры STM32'),
(2, 'Программирование Linux'),
(3, 'Электроника'),
(4, 'WEB-разработка'),
(5, 'Разное');

-- --------------------------------------------------------

--
-- Структура таблицы `comments`
--

CREATE TABLE `comments` (
  `id` int(10) UNSIGNED NOT NULL,
  `post_id` int(11) NOT NULL,
  `user_id` int(11) NOT NULL,
  `parent_comment_id` int(11) NOT NULL,
  `body` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Дамп данных таблицы `comments`
--

INSERT INTO `comments` (`id`, `post_id`, `user_id`, `parent_comment_id`, `body`, `created_at`, `updated_at`) VALUES
(1, 7, 1, 0, 'Поиск на сайте не работает', '2019-01-17 13:31:26', '2019-01-17 13:31:26');

-- --------------------------------------------------------

--
-- Структура таблицы `migrations`
--

CREATE TABLE `migrations` (
  `id` int(10) UNSIGNED NOT NULL,
  `migration` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `batch` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Дамп данных таблицы `migrations`
--

INSERT INTO `migrations` (`id`, `migration`, `batch`) VALUES
(1, '2014_10_12_000000_create_users_table', 1),
(2, '2014_10_12_100000_create_password_resets_table', 1),
(3, '2018_11_12_000000_create_categories_table', 1),
(4, '2018_11_12_000000_create_comments_table', 1),
(5, '2018_11_12_000000_create_posts_table', 1);

-- --------------------------------------------------------

--
-- Структура таблицы `password_resets`
--

CREATE TABLE `password_resets` (
  `email` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `token` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- --------------------------------------------------------

--
-- Структура таблицы `posts`
--

CREATE TABLE `posts` (
  `id` int(10) UNSIGNED NOT NULL,
  `user_id` int(11) NOT NULL,
  `category_id` int(11) NOT NULL,
  `title` varchar(220) COLLATE utf8mb4_unicode_ci NOT NULL,
  `intro` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `img` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `body` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Дамп данных таблицы `posts`
--

INSERT INTO `posts` (`id`, `user_id`, `category_id`, `title`, `intro`, `img`, `body`, `created_at`, `updated_at`) VALUES
(1, 1, 5, 'Соображения высшего порядка', 'а также консультация с профессионалами из IT требует определения и уточнения всесторонне сбалансированных нововведений. Повседневная практика показывает, что повышение уровня гражданского сознания играет важную роль в формировании модели развития? Разнообразный и богатый опыт постоянное информационно-техническое обеспечение нашей деятельности требует определения и уточнения дальнейших направлений развитая системы массового участия?', '../images/posts/2018-11-17_170848_Soobr_279.jpg', 'Таким образом, консультация с профессионалами из IT играет важную роль в формировании позиций, занимаемых участниками в отношении поставленных задач!\r\n\r\nПовседневная практика показывает, что новая модель организационной деятельности позволяет выполнить важнейшие задания по разработке дальнейших направлений развития проекта! Дорогие друзья, постоянный количественный рост и сфера нашей активности играет важную роль в формировании всесторонне сбалансированных нововведений. Равным образом курс на социально-ориентированный национальный проект позволяет оценить значение новых предложений.\r\n\r\nРавным образом социально-экономическое развитие напрямую зависит от дальнейших направлений развитая системы массового участия! Дорогие друзья, постоянный количественный рост и сфера нашей активности требует определения и уточнения позиций, занимаемых участниками в отношении поставленных задач. Задача организации, в особенности же новая модель организационной деятельности требует определения и уточнения модели развития. Не следует, однако, забывать о том, что реализация намеченного плана развития требует от нас анализа новых предложений. Практический опыт показывает, что реализация намеченного плана развития позволяет выполнить важнейшие задания по разработке всесторонне сбалансированных нововведений?', '2018-11-17 15:08:48', '2018-11-17 15:08:48'),
(2, 1, 3, 'Генератор с независимой регулировкой ширины и частоты биполярных импульсов', 'Биполярные импульсы преимущественно используют для поочередного переключения транзисторов в мостовых и полумостовых преобразователях напряжения. Хорошо известно, что при работе таких преобразователей на повышенных частотах на надежности их работы начинают фатально сказываться инерционные процессы рассасывания неосновных носителей тока в базовых цепях силовых транзисторов. В итоге последовательно включенные транзисторы могут одновременно оказаться в токопроводящем состоянии, несмотря на отсутствие управляющего сигнала. В этой связи с высокой долей вероятности возможен выход из строя дорогостоящих транзисторов за счет протекания через них неконтролируемого сквозного тока.', '../images/posts/2018-11-22_082119_Gener_89.jpeg', '<p>Для того чтобы снизить вероятность протекания сквозного тока между импульсами вводят паузу, длительность которой должна несколько превышать время рассасывания неосновных носителей тока.</p>\r\n\r\n<p>Способ получения серии биполярных импульсов из последовательности однополярных с использованием генератора импульсов, D-триггера, схем антисовпадений и операционного усилителя, питаемого от источника двуполярного напряжения, был впервые описан в британской печати [4] и затем продублирован в отечественной [5].</p>\r\n\r\n<p>Устройство (Рисунок 1) наследует выходные каскады формирователей [4, 5] и отличается возможностью плавного и независимого регулирования частоты и ширины биполярных импульсов.</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img alt=\"\" src=\"https://www.rlocman.ru/i/Image/2018/08/26/F_1.gif\" />Задающий генератор выполнен на элементе DD1.1 КМОП микросхемы CD40106. Рабочая частота генератора определяется RC-цепями: емкостью конденсатора С1 и суммарным сопротивлением резисторов и потенциометров R1&ndash;R5. Эту частоту можно плавно регулировать при помощи потенциометра R2 в пределах от 850 до 6000 Гц. Частоту работы генератора можно рассчитать по выражению</p>\r\n\r\n<p>где</p>\r\n\r\n<p>f &ndash; в кГц,<br />\r\nR &ndash; в кОм,<br />\r\nС &ndash; в мкФ.</p>\r\n\r\n<p>Резистивная цепочка R3&ndash;R5 подключена параллельно цепочке R1, R2. С движка потенциометра этой цепочки R4 снимается сигнал пилообразной формы, формируемый при заряде-разряде конденсатора С1. Этот сигнал, инвертированный элементом DD1.2 (триггер Шмитта, обладающий пороговым эффектом переключения), совместно с сигналом, снимаемым с выхода задающего генератора, поступает на элемент DD2.1 &laquo;ИЛИ&raquo; и на формирователь биполярных импульсов (элементы DD2.2, DD2.3, микросхема DA1), выполненный по ранее известной схеме [4, 5].</p>\r\n\r\n<p>Регулировка потенциометра R4 позволяет в широких пределах, практически от 0 до 100%, менять ширину выходных биполярных импульсов, не влияя на частоту работы генератора. Резисторы R3, R5 предназначены для ограничения пределов регулировки ширины импульсов по минимуму и по максимуму их длительности.</p>\r\n\r\n<h2>Литература</h2>\r\n\r\n<ol>\r\n	<li><a id=\"1\" name=\"1\"></a>Шустов М.А. Практическая схемотехника. Преобразователи напряжения. &ndash; М.: Altex-A, 2002. &ndash; Кн. 3. &ndash; 184 с.; М.: Додэка-XXI&ndash;Altex, 2007. &ndash; 192 с. (II изд.).</li>\r\n	<li>&nbsp;<a id=\"2\" name=\"2\"></a>Шустов М.А. Основы силовой электроники. &ndash; СПб.: Наука и Техника, 2017. &ndash; 336 с.</li>\r\n	<li><a id=\"3\" name=\"3\"></a>Shustov M.A., Shustov A.M. Electronic Circuits for All. &ndash; London: Elektor International Media BV, 2017. &ndash; 397 p.</li>\r\n	<li><a id=\"4\" name=\"4\"></a>Rauniar K.N. Unipolar-to-bipolar pulse converter // Electronics World + Wireless World. &ndash; 1989. &ndash; № 11. &ndash; P. 1098.</li>\r\n	<li><a id=\"5\" name=\"5\"></a>Васильев В. Задающий генератор преобразователя напряжения // Радио. &ndash; 2006. &ndash; № 10. &ndash; С. 47.</li>\r\n</ol>\r\n\r\n<h2>Материалы по теме</h2>\r\n\r\n<ol>\r\n	<li><a href=\"https://www.rlocman.ru/datasheet/data.html?di=450065&amp;/CA3140\">Datasheet Intersil CA3140</a></li>\r\n	<li><a href=\"https://www.rlocman.ru/datasheet/data.html?di=285915&amp;/CD4001B\">Datasheet Texas Instruments CD4001B</a></li>\r\n	<li><a href=\"https://www.rlocman.ru/datasheet/data.html?di=285981&amp;/CD40106B\">Datasheet Texas Instruments CD40106B</a></li>\r\n</ol>', '2018-11-22 06:21:19', '2018-11-22 06:21:19'),
(3, 1, 4, 'Настройка IP-адресов серверов DNS (настройка клиента DNS)', 'На всех *nix системах настройки DNS-клиента находятся в файле /etc/resolv.conf. Структура этого файла довольно простая - командами nameserver указывают IP-адреса серверов DNS. Комментариями считаются строки, если в начале стоит точка с запятой. Вот пример файла /etc/resolv.conf, взятого с RedHat Linux:', '../images/posts/2018-11-22_082248_Nastr_917.jpeg', '<pre>\r\n[root@localhost ~]# more /etc/resolv.conf\r\n; generated by /sbin/dhclient-script\r\nsearch yourlocaldomain.com\r\n;nameserver 213.234.192.8\r\n;nameserver 85.21.192.3\r\n;nameserver 217.10.44.35\r\n;nameserver 217.10.36.5\r\n;nameserver 217.10.39.4\r\nnameserver 80.252.130.254\r\nnameserver a.b.0.44\r\nnameserver a.b.0.1\r\nnameserver a.c.0.1\r\n</pre>\r\n\r\n<p>Здесь настроено 4 адреса IP сервера DNS, первый из них Интернетовский, а остальные - локальные.</p>\r\n\r\n<p>Директива&nbsp;<strong>search</strong>&nbsp;даёт нам список доменных имён, подразумеваемых в каждом DNS-запросе. Это позволяет вам связываться с машиной, используя только первую часть её FQDN (Fully Qualified Domain Name, полное доменное имя машины). Например, если в вашем пути search указан &ldquo;slackware.com&rdquo;, вы сможете обратиться к http://store.slackware.com, указав в своём веб-браузере только http://store.</p>\r\n\r\n<p>Если необходимо для некоторых имен обойти обращение к DNS-серверу, либо указать имя, которое нет в базе данных сервера DNS, то можно использовать файл&nbsp;<strong>/etc/hosts</strong>. При распознавании имен он обрабатывается в ПЕРВУЮ ОЧЕРЕДЬ. Пример файла /etc/hosts:</p>\r\n\r\n<pre>\r\n[root@FBSDlocalhost ~]# more /etc/hosts\r\n# $FreeBSD: src/etc/hosts,v 1.16 2003/01/28 21:29:23 dbaker Exp $\r\n#\r\n# Host Database\r\n#\r\n# This file should contain the addresses and aliases for local hosts that\r\n# share this file.  Replace &#39;my.domain&#39; below with the domainname of your\r\n# machine.\r\n#\r\n# In the presence of the domain name service or NIS, this file may\r\n# not be consulted at all; see /etc/nsswitch.conf for the resolution order.\r\n#\r\n#\r\n::1                     localhost localhost.my.domain\r\n127.0.0.1               localhost localhost.my.domain\r\n#\r\n# Imaginary network.\r\n#10.0.0.2               myname.my.domain myname\r\n#10.0.0.3               myfriend.my.domain myfriend\r\n#\r\n# According to RFC 1918, you can use the following IP networks for\r\n# private nets which will never be connected to the Internet:\r\n#\r\n#       10.0.0.0        -   10.255.255.255\r\n#       172.16.0.0      -   172.31.255.255\r\n#       192.168.0.0     -   192.168.255.255\r\n#\r\n# In case you want to be able to connect to the Internet, you need\r\n# real official assigned numbers.  Do not try to invent your own network\r\n# numbers but instead get one from your network provider (if any) or\r\n# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)\r\n#\r\n192.168.7.1             vm\r\n</pre>\r\n\r\n<p>Комментарии здесь начинаются с символа #. В этом примере настроено только одно имя - vm, оно преобразуется в IP 192.168.7.1 (не считая стандартного имени&nbsp;<strong>localhost</strong>). В одной строке можно прописывать несколько имен (через пробел).</p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p>Ссылка на оригинальную статью:&nbsp;http://microsin.net/adminstuff/xnix/dns-client.html</p>', '2018-11-22 06:22:48', '2018-11-22 06:22:48'),
(4, 1, 1, 'STM32 и FreeRTOS. 1. Развлечение с потоками.', 'Очень часто (да что там часто, практически всегда) микроконтроллеры применяют в условиях, когда необходимо отслеживать сразу несколько параметров. Или наоборот, управлять одновременно несколькими устройствами. Вот задача для примера: у нас есть 4 выхода, на которых необходимо выводить импульсы разной длительности с разными паузами. Все, что у нас есть – это системный таймер, который считает в миллисекундах.', '../images/posts/2018-11-22_082341_STM32_626.jpeg', '<p>Усложняем задачу в духе &ldquo;сам себя замучаю на ардуино&rdquo;. Таймеры заняты другим, PWM не подходит, ибо не на всех ножках он работает, да и не загонишь его на нужные режимы обычно. Немного подумав, садимся и пишем примерно такой код<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code>// инициализация\r\nint time1on=500; // Время, пока выход 1 должен быть включен\r\nint time1off=250; // Время, пока выход 1 должен быть выключен\r\nunsigned int now=millis();\r\n....\r\n// где-то в цикле\r\nif(millis()&lt;now+time1on)\r\n{\r\n  port1=ON;\r\n}\r\nelse\r\n{\r\nport1=OFF;\r\nif(millis()&gt;now+time1on+time1off)\r\n  {\r\n  now=millis();\r\n  }\r\n}\r\n</code></pre>\r\n\r\n<p><br />\r\n<br />\r\nИ так или примерно так для всех 4 портов. Получается приличная портянка на несколько экранов, но эта портянка работает и работает довольно быстро, что для микроконтроллера важно.<br />\r\n<br />\r\nПотом внезапно программист замечает, что при каждом цикле дергается порт, даже если его состояние не меняется. Правит всю портянку. Потом число портов с такими же потребностями увеличивается в два раза. Программист плюет и переписывает все в одну функцию типа PortBlink(int port num).<br />\r\n<br />\r\nПочти наступило счастье, но внезапно потребовалось что бы на каком-то порту вместе с управлением &ldquo;на выход&rdquo; что-то предварительно считывалось и уже на основе этого считанного управлялся порт. Программист снова матерится и делает еще одну функцию, специально под порт.<br />\r\n<br />\r\nСчастье? А вот фигу. Заказчик что-то этакое прицепил и это считанное может легко тормознуть процесс на секунды &hellip; Начинается стенания, программисты правят в очередной раз код, окончательно превращая его в нечитаемый треш, менеджеры выкатывают дикие прайсы заказчику за добавление функционала, заказчик матерится и решает больше никогда не связываться со встроенными решениями.<br />\r\n<br />\r\n(типа реклама и восхваление) А все почему? Потому что изначально было принято неправильное решение о платформе. Если есть возможность, мы предлагаем навороченную платформу даже для примитивных задач. По опыту стоимость разработки и поддержки потом оказываются гораздо ниже. Вот и сейчас для управления 8мю выходами я возьму STM32F3, который может работать на 72МГц. (шепотом) На самом деле просто у меня под рукой демоплата с ним (смаил). Была еще с L1, но мы ее нечаянно использовали в одном из проектов.<br />\r\n<br />\r\nОткрываем STM32Cube, выбираем плату, включаем галочку около FreeRTOS и собираем проект как обычно. Нам ничего этакого не надо, поэтому оставляем все по умолчанию.<br />\r\n<br />\r\nЧто такое FreeRTOS? Это операционная система почти реального времени для микроконтроллеров. То есть все, что вы слышали про операционные системы типа многозадачности, семафоров и прочих мутексов. Почему FreeRTOS? Просто ее поддерживает STM32Cube ;-). Есть куча других подобных систем &ndash; та же ChibiOS. По своей сути они все одинаковые, только различаются командами и их форматом. Тут я не собираюсь переписывать гору книг и инструкций по работе с операционными системами, просто пробегусь широкими мазками по наиболее интересным вещам, которые очень сильно помогают программистам в их нелегкой работе.<br />\r\n<br />\r\nЛадно, буду считать что прочитали в интернете и прониклись. Смотрим, что поменялось<br />\r\n<br />\r\nГде-то в начале main.c<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code>static void StartThread(void const * argument);\r\n</code></pre>\r\n\r\n<p><br />\r\n<br />\r\nи после всех инициализаций<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code>/* Create Start thread */\r\nosThreadDef(USER_Thread, StartThread, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);\r\nosThreadCreate (osThread(USER_Thread), NULL);\r\n\r\n/* Start scheduler */\r\nosKernelStart(NULL, NULL);\r\n\r\n</code></pre>\r\n\r\n<p><br />\r\n<br />\r\nИ пустая StartThread с одним бесконечным циклом и osDelay(1);<br />\r\n<br />\r\nУдивлены? А между тем перед вами практически 90% функционала, которые вы будете использовать. Первые две строки создают поток с нормальными приоритетом, а последняя строка запускает в работу планировщик задач. И все это великолепие укладывается в 6 килобайт флеша.<br />\r\n<br />\r\nНо нам надо проверить работу. Меняем osDelay на следующий код<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code>HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_RESET);\r\nosDelay(500);\r\nHAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_SET);\r\nosDelay(500);\r\n</code></pre>\r\n\r\n<p><br />\r\n<br />\r\nКомпилируем и заливаем. Если все сделано правильно, то у нас должен замигать синий светодиодик (на STM32F3Discovery на PE8-PE15 распаяна кучка светодиодов, поэтому если у вас другая плата, то смените код)<br />\r\n<br />\r\nА теперь возьмем и растиражируем полученную функцию для каждого светодиода.<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code>static void PE8Thread(void const * argument);\r\nstatic void PE9Thread(void const * argument);\r\nstatic void PE10Thread(void const * argument);\r\nstatic void PE11Thread(void const * argument);\r\nstatic void PE12Thread(void const * argument);\r\nstatic void PE13Thread(void const * argument);\r\nstatic void PE14Thread(void const * argument);\r\nstatic void PE15Thread(void const * argument);\r\n</code></pre>\r\n\r\n<p><br />\r\n<br />\r\nДобавим поток для каждого светодиода</p>\r\n\r\n<pre>\r\n<code>osThreadDef(PE8_Thread, PE8Thread, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);\r\nosThreadCreate (osThread(PE8_Thread), NULL);\r\n\r\n</code></pre>\r\n\r\n<p><br />\r\nИ перенесем туда код для зажигания светодиода</p>\r\n\r\n<pre>\r\n<code>static void PE8Thread(void const * argument)\r\n{\r\nfor(;;)\r\n  {\r\n    HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_RESET);\r\n    osDelay(500);\r\n    HAL_GPIO_WritePin(GPIOE,GPIO_PIN_8,GPIO_PIN_SET);\r\n    osDelay(500);\r\n  }\r\n}\r\n</code></pre>\r\n\r\n<p><br />\r\n<br />\r\nВ общем все однотипно.<br />\r\n<br />\r\nКомпилируем, заливаем &hellip; и получаем фигу. Полную. Ни один светодиод не мигает.<br />\r\n<br />\r\nПутем страшной отладки методом комментирования выясняем, что 3 потока работают, а 4 &ndash; уже нет. В чем проблема? Проблема в выделенной памяти для шедулера и стека.<br />\r\n<br />\r\nСмотрим в FreeRTOSConfig.h<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code>#define configMINIMAL_STACK_SIZE ((unsigned short)128)\r\n#define configTOTAL_HEAP_SIZE ((size_t)3000)\r\n</code></pre>\r\n\r\n<p><br />\r\n<br />\r\n3000 байт на все и каждой задаче 128 байт. Плюс еще где-то надо хранить информацию о задаче и прочем полезном. Вот поэтому, если ничего не делать, планировщик при нехватке памяти даже не стартует.<br />\r\n<br />\r\nСудя по факам, если включить полную оптимизацию, то сам FreeRTOS возьмет 250 байт. Плюс на каждую задачу по 128 байт для стека, 64 для внутреннего списка и 16 для имени задачи. Считаем: 250+3*(128+64+16)=874. Даже до килобайта не дотягивает. А у нас 3 &hellip;<br />\r\n<br />\r\nВ чем проблема? Поставляемая с STM32Cube версия FreeRTOS слишком старая (7.6.0), что бы заиметь vTaskInfo, поэтому я захожу сбоку:<br />\r\n<br />\r\nПеред и после создания потока я поставил следующее (fre &ndash; это обычный size_t)<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code>fre=xPortGetFreeHeapSize();\r\n</code></pre>\r\n\r\n<p><br />\r\n<br />\r\nВтыкаем брекпоинты и получаем следующие цифры: перед созданием задачи было 2376 свободных байт, а после 1768. То есть на одну задачу уходит 608 байт. Проверяем еще. Получаем цифры 2992-2376-1768-1160. Цифра совпадает. Путем простых логических умозаключений понимаем, что те цифры из фака взяты для какого-нибудь дохлого процессора, со включенными оптимизациями и выключенными всякими модулями. Смотрим дальше и понимаем, что старт шедулера отьедает еще примерно 580 байт.<br />\r\n<br />\r\nВ общем, принимаем для расчетов 610 байт на задачу с минимальным стеком и еще 580 байт для самой ОС. Итого в TOTAL_HEAP_SIZE надо записать 610*9+580=6070. Округлим и отдадим 6100 байт &ndash; пусть жирует.<br />\r\n<br />\r\nКомпилируем, заливаем и наблюдаем, как мигают все светодиоды разом. Пробуем уменьшить стек до 6050 &ndash; опять ничего не работает. Значит, мы подсчитали правильно :)<br />\r\n<br />\r\nТеперь можно побаловаться и позадавать для каждого светодиодика свои промежутки &ldquo;импульса&rdquo; и &ldquo;паузы&rdquo;. В принципе, если обновить FreeRTOS или поколдовать в коде, то легко дать точность на уровне 0,01мс (по умолчанию 1 тик &ndash; 1мс).<br />\r\n<br />\r\nСогласитесь, работать с 8ю задачами поодиночке гораздо приятней, чем в одной с 8ю одновременно? В реальности у нас в проектах обычно крутится по 30-40 потоков. Сколько было бы смертей программистов, если всю их обработку запихать в одну функцию я даже подсчитать боюсь :)<br />\r\n<br />\r\nСледующим шагом нам необходимо разобраться с приоритетами. Как и в реальной жизни, некоторые задачи &ldquo;равнее&rdquo; остальных и им необходимо больше ресурсов. Для начала заменим одну мигалку мигалкой же, но сделанной неправильно, когда пауза делается не средствами ОС, а простым циклом.<br />\r\n<br />\r\nТо есть вместо osDelay() вставляется вот такой вот ужас.<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code>unsigned long c;\r\nfor(int i=0;i&lt;1000000;i++)\r\n{\r\n  c++;\r\n}\r\n</code></pre>\r\n\r\n<p><br />\r\n<br />\r\nЧисло циклов обычно подбирается экспериментально (ибо если таких задержек несколько, то куча головной боли в расчетах обеспечено). Эстеты могут подчитать время выполнения команд.<br />\r\n<br />\r\nЗаменяем, компилируем, запускаем. Светодиодики мигают по прежнему, но как-то вяло. Просмотр осциллографом дает понять, что вместо ровных границ (типа 50мс горим и 50мс не горим), границы стали плавать на 1-2мс (глаз, как ни странно, это замечает). Почему? Потому что FreeRTOS не система реального времени и может позволить себе такие вольности.<br />\r\n<br />\r\nА теперь давайте поднимем приоритет этой задаче на один шажок, до osPriorityAboveNormal. Запустим и увидим одиноко мигающий светодиод. Почему?<br />\r\n<br />\r\nПотому что планировщик распределяет задачи по приоритетам. Что он видит? Что задача с высоким приоритетом постоянно требует процессор. Что в результате? Остальным задачам времени на работу не остается.<br />\r\n<br />\r\nА теперь понизим приоритет на один шаг от нормального, до osPriorityBelowNormal. В результате планировщик, дав поработать нормальным задачам, отдает оставшиеся ресурсы &laquo;плохой&raquo;.<br />\r\n<br />\r\nОтсюда можно легко вывести первое правило программиста: если функции нечего делать, то отдай управление планировщику.<br />\r\n<br />\r\nВ FreeRTOS есть два варианта &laquo;подожди&raquo;<br />\r\n<br />\r\nПервый вариант &laquo;просто подожди N тиков&raquo;. Обычная пауза, без каких либо изысков: сколько сказали подождать, столько и ждем. Это vTaskDelay (osDelay просто синоним). Если посмотреть на время во время выполнения, то будет примерно следующее (примем что полезная задача выполняется 24мс):<br />\r\n<br />\r\n&hellip; [0ms] &mdash; передача управления &mdash; работа [24ms] пауза в 100мс [124ms] &mdash; передача управления &mdash; работа [148ms] пауза в 100мс [248ms]&hellip;<br />\r\n<br />\r\nЛегко увидеть, что из-за времени, требуемой на работу, передача управления происходит не каждые 100мс, как изначально можно было бы предположить. Для таких случаев есть vTaskDelayUntil. С ней временная линия будет выглядеть вот так<br />\r\n<br />\r\n&hellip; [0ms] &mdash; передача управления &mdash; работа [24ms] пауза в 76мс [100ms] &mdash; передача управления &mdash; работа [124ms] пауза в 76мс [200ms]&hellip;<br />\r\n<br />\r\nКак видно, задача получает управление в четко обозначенные временные промежутки, что нам и требовалось. Для проверки точности планировщика в одном из потоков я попросил делать паузы по 1мс. На картинке можете оценить точность работы с 9ю потоками (про StartThread не забываем)<br />\r\n<br />\r\n<img src=\"https://habrastorage.org/files/8cd/b1e/567/8cdb1e56700e4a51bd7d70cd282c54e2.png\" /><br />\r\n<br />\r\n<em>На этом я обычно заканчиваю, ибо народ настолько погружается в игру с приоритетами и выяснением &laquo;когда оно сломается&raquo;, что проще замолчать и дать поразвлекаться.&nbsp;</em></p>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><em>Статья взята&nbsp;<a href=\"https://habr.com/post/249273/\">отсюда</a>.</em></p>', '2018-11-22 06:23:41', '2018-11-22 06:23:41'),
(5, 1, 3, 'Фильтр подавляет помеху 60 Гц.', 'Изображенная на рисунке - схема, очищает от помехи 60 Гц слабые низкочастотные сигналы, потребляя не более 95 мкА от единственного источника питания 5 В.', '../images/posts/2018-11-22_082515_Filyt_521.jpeg', '<p>Резисторы R1, R2, R3&nbsp;и конденсаторы C1, C2, C3&nbsp;образуют классический двойной T-мост, а микросхемы IC1&nbsp;и IC2&nbsp;обеспечивают местную и общую обратную связь. Добротность Q и характеристики подавления этого активного фильтра очень чувствительны к относительному согласованию сопротивлений резисторов и емкостей конденсаторов секции двойного T-моста. Таблица 1 демонстрирует зависимость коэффициента подавления и добротности от сопротивления резистора RQ.</p>\r\n\r\n<table align=\"center\" border=\"0\" cellpadding=\"4\" cellspacing=\"0\">\r\n	<tbody>\r\n		<tr>\r\n			<td><em>Таблица 1.</em></td>\r\n			<td><em><strong>Зависимость коэффициента подавления<br />\r\n			фильтра на частоте 60 Гц и добротности<br />\r\n			от сопротивления резистора RQ</strong></em>.</td>\r\n		</tr>\r\n		<tr>\r\n			<td colspan=\"2\">\r\n			<table align=\"center\" border=\"1\" cellpadding=\"3\" cellspacing=\"0\">\r\n				<tbody>\r\n					<tr>\r\n						<td><strong>Q фильтра</strong></td>\r\n						<td><strong>RQ<br />\r\n						(кОм)</strong></td>\r\n						<td><strong>Подавление<br />\r\n						(дБ)</strong></td>\r\n						<td><strong>VOUT/VIN</strong></td>\r\n					</tr>\r\n					<tr>\r\n						<td>0.75</td>\r\n						<td>1</td>\r\n						<td>40</td>\r\n						<td>1.33</td>\r\n					</tr>\r\n					<tr>\r\n						<td>1.25</td>\r\n						<td>2</td>\r\n						<td>35</td>\r\n						<td>1.5</td>\r\n					</tr>\r\n					<tr>\r\n						<td>2.5</td>\r\n						<td>3</td>\r\n						<td>30</td>\r\n						<td>1.6</td>\r\n					</tr>\r\n					<tr>\r\n						<td>2.5</td>\r\n						<td>8</td>\r\n						<td>25</td>\r\n						<td>1.8</td>\r\n					</tr>\r\n					<tr>\r\n						<td>5</td>\r\n						<td>18</td>\r\n						<td>20</td>\r\n						<td>1.9</td>\r\n					</tr>\r\n					<tr>\r\n						<td>10</td>\r\n						<td>38</td>\r\n						<td>15</td>\r\n						<td>1.95</td>\r\n					</tr>\r\n				</tbody>\r\n			</table>\r\n			</td>\r\n		</tr>\r\n	</tbody>\r\n</table>\r\n\r\n<p>R4, R5, C4&nbsp;и IC3&nbsp;образуют низкоимпедансный опорный источник, смещающий IC1&nbsp;и секции двойного T-моста на половину напряжения питания.</p>\r\n\r\n<p>Чтобы настроить фильтр на 60 Гц, выберите такое значение Q, которое обеспечит достаточное ослабление без чрезмерных потерь полезных низкочастотных сигналов, частоты которых могут располагаться вблизи частоты подавления фильтра. Сопротивление RQвычисляется как</p>\r\n\r\n<p><img alt=\"\" src=\"https://www.rlocman.ru/i/Image/2017/07/19/F_1.gif\" /></p>\r\n\r\n<p>Коэффициент усиления выходного каскада рассчитывается как для обычного неинвертирующего усилителя:</p>\r\n\r\n<p><img alt=\"\" src=\"https://www.rlocman.ru/i/Image/2017/07/19/F_2.gif\" /></p>\r\n\r\n<p>а общее усиление полосового режекторного фильтра выше и ниже частоты подавления выражается как</p>\r\n\r\n<p><img alt=\"\" src=\"https://www.rlocman.ru/i/Image/2017/07/19/F_3.gif\" /></p>\r\n\r\n<p>Если потребуется дополнительное подавление, секции фильтра можно каскадировать. Имейте в виду, что при этом, возможно, вам придется видоизменить схему, чтобы учесть внеполосное усиление.</p>\r\n\r\n<h2>Материалы по теме</h2>\r\n\r\n<ol>\r\n	<li><a href=\"https://www.rlocman.ru/datasheet/data.html?di=335109&amp;/OP490\">Datasheet Analog Devices OP490</a></li>\r\n</ol>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><em>Перевод: AlexAAN по заказу&nbsp;<a href=\"https://www.rlocman.ru/\" target=\"_blank\">РадиоЛоцман</a></em></p>\r\n\r\n<p>На английском языке:&nbsp;<a href=\"https://www.radiolocman.com/shem/schematics.html?di=337441\" target=\"_blank\">Filter quashes 60-Hz interference</a></p>\r\n\r\n<p>Русская версия:&nbsp;https://www.rlocman.ru/shem/schematics.html?di=337441</p>', '2018-11-22 06:25:15', '2018-11-22 06:25:15'),
(6, 1, 2, 'Пишем простой модуль ядра Linux', 'Linux предоставляет мощный и обширный API для приложений, но иногда его недостаточно. Для взаимодействия с оборудованием или осуществления операций с доступом к привилегированной информации в системе нужен драйвер ядра. Модуль ядра Linux — это скомпилированный двоичный код, который вставляется непосредственно в ядро Linux, работая в кольце 0, внутреннем и наименее защищённом кольце выполнения команд в процессоре x86–64. Здесь код исполняется совершенно без всяких проверок, но зато на невероятной скорости и с доступом к любым ресурсам системы.', '../images/posts/2018-11-22_082630_Pishe_370.jpeg', '<p>Написание модуля ядра Linux &mdash; занятие не для слабонервных. Изменяя ядро, вы рискуете потерять данные. В коде ядра нет стандартной защиты, как в обычных приложениях Linux. Если сделать ошибку, то повесите всю систему.</p>\r\n\r\n<p><br />\r\nСитуация ухудшается тем, что проблема необязательно проявляется сразу. Если модуль вешает систему сразу после загрузки, то это наилучший сценарий сбоя. Чем больше там кода, тем выше риск бесконечных циклов и утечек памяти. Если вы неосторожны, то проблемы станут постепенно нарастать по мере работы машины. В конце концов важные структуры данных и даже буфера могут быть перезаписаны.</p>\r\n\r\n<p><br />\r\nМожно в основном забыть традиционные парадигмы разработки приложений. Кроме загрузки и выгрузки модуля, вы будете писать код, который реагирует на системные события, а не работает по последовательному шаблону. При работе с ядром вы пишете API, а не сами приложения.<br />\r\nУ вас также нет доступа к стандартной библиотеке. Хотя ядро предоставляет некоторые функции вроде&nbsp;<code>printk</code>&nbsp;(которая служит заменой&nbsp;<code>printf</code>) и&nbsp;<code>kmalloc</code>&nbsp;(работает похоже на&nbsp;<code>malloc</code>), в основном вы остаётесь наедине с железом. Вдобавок, после выгрузки модуля следует полностью почистить за собой. Здесь нет сборки мусора.</p>\r\n\r\n<h2>Необходимые компоненты</h2>\r\n\r\n<p>Прежде чем начать, следует убедиться в наличии всех необходимых инструментов для работы. Самое главное, нужна машина под Linux. Знаю, это неожиданно! Хотя подойдёт любой дистрибутив Linux, в этом примере я использую Ubuntu 16.04 LTS, так что в случае использования других дистрибутивов может понадобиться слегка изменить команды установки.<br />\r\n<br />\r\nВо-вторых, нужна или отдельная физическая машина, или виртуальная машина. Лично я предпочитаю работать на виртуальной машине, но выбирайте сами. Не советую использовать свою основную машину из-за потери данных, когда сделаете ошибку. Я говорю &laquo;когда&raquo;, а не &laquo;если&raquo;, потому что вы обязательно подвесите машину хотя бы несколько раз в процессе. Ваши последние изменения в коде могут ещё находиться в буфере записи в момент паники ядра, так что могут повредиться и ваши исходники. Тестирование в виртуальной машине устраняет эти риски.<br />\r\n<br />\r\nИ наконец, нужно хотя бы немного знать C. Рабочая среда C++ слишком велика для ядра, так что необходимо писать на чистом голом C. Для взаимодействия с оборудованием не помешает и некоторое знание ассемблера.</p>\r\n\r\n<h2>Установка среды разработки</h2>\r\n\r\n<p>На Ubuntu нужно запустить:</p>\r\n\r\n<pre>\r\n<code>apt-get install build-essential linux-headers-`uname -r`</code></pre>\r\n\r\n<p>Устанавливаем самые важные инструменты разработки и заголовки ядра, необходимые для данного примера.<br />\r\nПримеры ниже предполагают, что вы работаете из-под обычного пользователя, а не рута, но что у вас есть привилегии sudo. Sudo необходима для загрузки модулей ядра, но мы хотим работать по возможности за пределами рута.</p>\r\n\r\n<h2>Начинаем</h2>\r\n\r\n<p>Приступим к написанию кода. Подготовим нашу среду:</p>\r\n\r\n<pre>\r\n<code>mkdir ~/src/lkm_example\r\ncd ~/src/lkm_example</code></pre>\r\n\r\n<p>Запустите любимый редактор (в моём случае это vim) и создайте файл&nbsp;<code>lkm_example.c</code>&nbsp;следующего содержания:</p>\r\n\r\n<pre>\r\n<code>#include &lt;linux/init.h&gt;\r\n#include &lt;linux/module.h&gt;\r\n#include &lt;linux/kernel.h&gt;\r\nMODULE_LICENSE(“GPL”);\r\nMODULE_AUTHOR(“Robert W. Oliver II”);\r\nMODULE_DESCRIPTION(“A simple example Linux module.”);\r\nMODULE_VERSION(“0.01”);\r\nstatic int __init lkm_example_init(void) {\r\n printk(KERN_INFO “Hello, World!\r\n”);\r\n return 0;\r\n}\r\nstatic void __exit lkm_example_exit(void) {\r\n printk(KERN_INFO “Goodbye, World!\r\n”);\r\n}\r\nmodule_init(lkm_example_init);\r\nmodule_exit(lkm_example_exit);</code></pre>\r\n\r\n<p><br />\r\nМы сконструировали самый простой возможный модуль, рассмотрим подробнее самые важные его части:</p>\r\n\r\n<ul>\r\n	<li>В&nbsp;<code>include</code>&nbsp;перечислены файлы заголовков, необходимые для разработки ядра Linux.</li>\r\n	<li>В&nbsp;<code>MODULE_LICENSE</code>&nbsp;можно установить разные значения, в зависимости от лицензии модуля. Для просмотра полного списка запустите:&nbsp;\r\n	<pre>\r\n<code> grep “MODULE_LICENSE” -B 27 /usr/src/linux-headers-`uname -r`/include/linux/module.h</code></pre>\r\n	</li>\r\n	<li>Мы устанавливаем&nbsp;<code>init</code>&nbsp;(загрузка) и&nbsp;<code>exit</code>&nbsp;(выгрузка) как статические функции, которые возвращают целые числа.</li>\r\n	<li>Обратите внимание на использование&nbsp;<code>printk</code>&nbsp;вместо&nbsp;<code>printf</code>. Также параметры&nbsp;<code>printk</code>&nbsp;отличаются от&nbsp;<code>printf</code>. Например, флаг KERN_INFO для объявления приоритета журналирования для конкретной строки указывается без запятой. Ядро разбирается с этими вещами внутри функции&nbsp;<code>printk</code>&nbsp;для экономии памяти стека.</li>\r\n	<li>В конце файла можно вызвать&nbsp;<code>module_init</code>&nbsp;и&nbsp;<code>module_exit</code>&nbsp;и указать функции загрузки и выгрузки. Это даёт возможность произвольного именования функций.</li>\r\n</ul>\r\n\r\n<p>Впрочем, пока мы не можем скомпилировать этот файл. Нужен Makefile. Такого базового примера пока достаточно. Обратите внимание, что&nbsp;<code>make</code>&nbsp;очень привередлив к пробелам и табам, так что убедитесь, что используете табы вместо пробелов где положено.</p>\r\n\r\n<pre>\r\n<code>obj-m += lkm_example.o\r\nall:\r\n make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\r\nclean:\r\n make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</code></pre>\r\n\r\n<p>Если мы запускаем&nbsp;<code>make</code>, он должен успешно скомпилировать наш модуль. Результатом станет файл&nbsp;<code>lkm_example.ko</code>. Если выскакивают какие-то ошибки, проверьте, что кавычки в исходном коде установлены корректно, а не случайно в кодировке UTF-8.<br />\r\n<br />\r\nТеперь можно внедрить модуль и проверить его. Для этого запускаем:</p>\r\n\r\n<pre>\r\n<code>sudo insmod lkm_example.ko</code></pre>\r\n\r\n<p>Если всё нормально, то вы ничего не увидите. Функция&nbsp;<code>printk</code>&nbsp;обеспечивает выдачу не в консоль, а в журнал ядра. Для просмотра нужно запустить:</p>\r\n\r\n<pre>\r\n<code>sudo dmesg</code></pre>\r\n\r\n<p>Вы должны увидеть строку &ldquo;Hello, World!&rdquo; с меткой времени в начале. Это значит, что наш модуль ядра загрузился и успешно сделал запись в журнал ядра. Мы можем также проверить, что модуль ещё в памяти:</p>\r\n\r\n<pre>\r\n<code>lsmod | grep “lkm_example”</code></pre>\r\n\r\n<p>Для удаления модуля запускаем:</p>\r\n\r\n<pre>\r\n<code>sudo rmmod lkm_example</code></pre>\r\n\r\n<p>Если вы снова запустите dmesg, то увидите в журнале запись &ldquo;Goodbye, World!&rdquo;. Можно снова запустить lsmod и убедиться, что модуль выгрузился.<br />\r\n<br />\r\nКак видите, эта процедура тестирования слегка утомительна, но её можно автоматизировать, добавив:</p>\r\n\r\n<pre>\r\n<code>test:\r\n sudo dmesg -C\r\n sudo insmod lkm_example.ko\r\n sudo rmmod lkm_example.ko\r\n dmesg</code></pre>\r\n\r\n<p>в конце Makefile, а потом запустив:<br />\r\n&nbsp;</p>\r\n\r\n<pre>\r\n<code>make test</code></pre>\r\n\r\n<p>для тестирования модуля и проверки выдачи в журнал ядра без необходимости запускать отдельные команды.<br />\r\nТеперь у нас есть полностью функциональный, хотя и абсолютно тривиальный модуль ядра!</p>\r\n\r\n<h2>Немного интереснее</h2>\r\n\r\n<p>Копнём чуть глубже. Хотя модули ядра способны выполнять все виды задач, взаимодействие с приложениями &mdash; один из самых распространённых вариантов использования.<br />\r\n<br />\r\nПоскольку приложениям запрещено просматривать память в пространстве ядра, для взаимодействия с ними приходится использовать API. Хотя технически есть несколько способов такого взаимодействия, наиболее привычный &mdash; создание файла устройства.<br />\r\n<br />\r\nВероятно, раньше вы уже имели дело с файлами устройств. Команды с упоминанием&nbsp;<code>/dev/zero</code>,&nbsp;<code>/dev/null</code>&nbsp;и тому подобного взаимодействуют с устройствами &ldquo;zero&rdquo; и &ldquo;null&rdquo;, которые возвращают ожидаемые значения.<br />\r\n<br />\r\nВ нашем примере мы возвращаем &ldquo;Hello, World&rdquo;. Хотя это не особенно полезная функция для приложений, она всё равно демонстрирует процесс взаимодействия с приложением через файл устройства.<br />\r\n<br />\r\nВот полный листинг:</p>\r\n\r\n<pre>\r\n<code>#include &lt;linux/init.h&gt;\r\n#include &lt;linux/module.h&gt;\r\n#include &lt;linux/kernel.h&gt;\r\n#include &lt;linux/fs.h&gt;\r\n#include &lt;asm/uaccess.h&gt;\r\nMODULE_LICENSE(“GPL”);\r\nMODULE_AUTHOR(“Robert W. Oliver II”);\r\nMODULE_DESCRIPTION(“A simple example Linux module.”);\r\nMODULE_VERSION(“0.01”);\r\n#define DEVICE_NAME “lkm_example”\r\n#define EXAMPLE_MSG “Hello, World!\r\n”\r\n#define MSG_BUFFER_LEN 15\r\n/* Prototypes for device functions */\r\nstatic int device_open(struct inode *, struct file *);\r\nstatic int device_release(struct inode *, struct file *);\r\nstatic ssize_t device_read(struct file *, char *, size_t, loff_t *);\r\nstatic ssize_t device_write(struct file *, const char *, size_t, loff_t *);\r\nstatic int major_num;\r\nstatic int device_open_count = 0;\r\nstatic char msg_buffer[MSG_BUFFER_LEN];\r\nstatic char *msg_ptr;\r\n/* This structure points to all of the device functions */\r\nstatic struct file_operations file_ops = {\r\n .read = device_read,\r\n .write = device_write,\r\n .open = device_open,\r\n .release = device_release\r\n};\r\n/* When a process reads from our device, this gets called. */\r\nstatic ssize_t device_read(struct file *flip, char *buffer, size_t len, loff_t *offset) {\r\n int bytes_read = 0;\r\n /* If we’re at the end, loop back to the beginning */\r\n if (*msg_ptr == 0) {\r\n msg_ptr = msg_buffer;\r\n }\r\n /* Put data in the buffer */\r\n while (len &amp;&amp; *msg_ptr) {\r\n /* Buffer is in user data, not kernel, so you can’t just reference\r\n * with a pointer. The function put_user handles this for us */\r\n put_user(*(msg_ptr++), buffer++);\r\n len--;\r\n bytes_read++;\r\n }\r\n return bytes_read;\r\n}\r\n/* Called when a process tries to write to our device */\r\nstatic ssize_t device_write(struct file *flip, const char *buffer, size_t len, loff_t *offset) {\r\n /* This is a read-only device */\r\n printk(KERN_ALERT “This operation is not supported.\r\n”);\r\n return -EINVAL;\r\n}\r\n/* Called when a process opens our device */\r\nstatic int device_open(struct inode *inode, struct file *file) {\r\n /* If device is open, return busy */\r\n if (device_open_count) {\r\n return -EBUSY;\r\n }\r\n device_open_count++;\r\n try_module_get(THIS_MODULE);\r\n return 0;\r\n}\r\n/* Called when a process closes our device */\r\nstatic int device_release(struct inode *inode, struct file *file) {\r\n /* Decrement the open counter and usage count. Without this, the module would not unload. */\r\n device_open_count--;\r\n module_put(THIS_MODULE);\r\n return 0;\r\n}\r\nstatic int __init lkm_example_init(void) {\r\n /* Fill buffer with our message */\r\n strncpy(msg_buffer, EXAMPLE_MSG, MSG_BUFFER_LEN);\r\n /* Set the msg_ptr to the buffer */\r\n msg_ptr = msg_buffer;\r\n /* Try to register character device */\r\n major_num = register_chrdev(0, “lkm_example”, &amp;file_ops);\r\n if (major_num &lt; 0) {\r\n printk(KERN_ALERT “Could not register device: %d\r\n”, major_num);\r\n return major_num;\r\n } else {\r\n printk(KERN_INFO “lkm_example module loaded with device major number %d\r\n”, major_num);\r\n return 0;\r\n }\r\n}\r\nstatic void __exit lkm_example_exit(void) {\r\n /* Remember — we have to clean up after ourselves. Unregister the character device. */\r\n unregister_chrdev(major_num, DEVICE_NAME);\r\n printk(KERN_INFO “Goodbye, World!\r\n”);\r\n}\r\n/* Register module functions */\r\nmodule_init(lkm_example_init);\r\nmodule_exit(lkm_example_exit);</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h3>Тестирование улучшенного примера</h3>\r\n\r\n<p>Теперь наш пример делает нечто большее, чем просто вывод сообщения при загрузке и выгрузке, так что понадобится менее строгая процедура тестирования. Изменим Makefile только для загрузки модуля, без его выгрузки.</p>\r\n\r\n<pre>\r\n<code>obj-m += lkm_example.o\r\nall:\r\n  make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules\r\nclean:\r\n  make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean\r\ntest:\r\n  # We put a — in front of the rmmod command to tell make to ignore\r\n  # an error in case the module isn’t loaded.\r\n  -sudo rmmod lkm_example\r\n  # Clear the kernel log without echo\r\n  sudo dmesg -C\r\n  # Insert the module\r\n  sudo insmod lkm_example.ko\r\n  # Display the kernel log\r\n  dmesg</code></pre>\r\n\r\n<p><br />\r\nТеперь после запуска&nbsp;<code>make test</code>&nbsp;вы увидите выдачу старшего номера устройства. В нашем примере его автоматически присваивает ядро. Однако этот номер нужен для создания нового устройства.<br />\r\nВозьмите номер, полученный в результате выполнения&nbsp;<code>make test</code>, и используйте его для создания файла устройства, чтобы можно было установить коммуникацию с нашим модулем ядра из пространства пользователя.</p>\r\n\r\n<pre>\r\n<code>sudo mknod /dev/lkm_example c MAJOR 0</code></pre>\r\n\r\n<p>(в этом примере замените MAJOR значением, полученным в результате выполнения&nbsp;<code>make test</code>&nbsp;или&nbsp;<code>dmesg</code>)<br />\r\nПараметр&nbsp;<code>c</code>&nbsp;в команде&nbsp;<code>mknod</code>&nbsp;говорит mknod, что нам нужно создать файл символьного устройства.<br />\r\nТеперь мы можем получить содержимое с устройства:</p>\r\n\r\n<pre>\r\n<code>cat /dev/lkm_example</code></pre>\r\n\r\n<p>или даже через команду&nbsp;<code>dd</code>:</p>\r\n\r\n<pre>\r\n<code>dd if=/dev/lkm_example of=test bs=14 count=100</code></pre>\r\n\r\n<p>Вы также можете получить доступ к этому файлу из приложений. Это необязательно должны быть скомпилированные приложения&nbsp;&mdash;  даже у скриптов Python, Ruby и PHP есть доступ к этим данным.<br />\r\nКогда мы закончили с устройством, удаляем его и выгружаем модуль:</p>\r\n\r\n<pre>\r\n<code>sudo rm /dev/lkm_example\r\nsudo rmmod lkm_example</code></pre>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<h2>Заключение</h2>\r\n\r\n<p>Надеюсь, вам понравились наши шалости в пространстве ядра. Хотя показанные примеры примитивны, эти структуры можно использовать для создания собственных модулей, выполняющих очень сложные задачи.<br />\r\n<br />\r\nПросто помните, что в пространстве ядра всё под вашу ответственность. Там для вашего кода нет поддержки или второго шанса. Если делаете проект для клиента, заранее запланируйте двойное, если не тройное время на отладку. Код ядра должен быть идеален, насколько это возможно, чтобы гарантировать цельность и надёжность систем, на которых он запускается.</p>\r\n\r\n<p>Источник:&nbsp;<a href=\"https://habr.com/post/343828/\">habr.com</a></p>', '2018-11-22 06:26:30', '2018-11-22 06:26:30');
INSERT INTO `posts` (`id`, `user_id`, `category_id`, `title`, `intro`, `img`, `body`, `created_at`, `updated_at`) VALUES
(7, 1, 1, 'Компьютер Orange Pi PC в качестве Linux WEB сервера. Часть 1. Установка Linux.', 'В этой статье мы рассмотрим: установка образа Linux из Windows, установка образа Linux из Mac OS, установка образа Linux из Linux, перенос системы во встроенную память (nand).', '../images/posts/2018-11-22_083627_Kompy_23.jpeg', '<p>Сердцем одноплатника является четырехядерный процессор H3 Cortex-A7 частотой 1.2 ГГц в нормальном режиме и 1.6 ГГц в турбо режиме. Оперативной памяти &mdash; 1 ГБ, двумя 512МБ чипами, мини компьютер оснащен тремя портами USB 2.0, micro USB &mdash; OTG, 100 МБ Ethernet, HDMI, и слотом для micro SD.</p>\r\n\r\n<ul>\r\n</ul>\r\n\r\n<h3>Установка образа Linux из Windows</h3>\r\n\r\n<p>Установить (записать) образ ОС для Orange Pi PC используя компьютер с Windows - очень просто. Для этого нам потребуется карта памяти MicroSD и последняя версия&nbsp;<a href=\"https://miniboard.com.ua/index.php?controller=attachment&amp;id_attachment=7\">Win32Imager</a>, скачайте, установите и запустите данную утилиту (образ желаемой ОС уже должен быть скачан и распакован из архива, итоговый файл должен быть с расширением .img).</p>\r\n\r\n<p>В окне Win32 Disk Imager выберите файл образа, находящийся на Вашем диске и букву диска, которая соответствует карте памяти microSD на которую необходимо записать образ операционной системы и нажмите&nbsp;<strong>Write</strong>, а затем&nbsp;подтвердите запись на карту памяти нажатием&nbsp;<strong>Yes</strong>&nbsp;в окне подтверждения (будьте внимательны, этот процесс полностью удалит все данные с карты памяти).</p>\r\n\r\n<p><img alt=\"\" src=\"https://miniboard.com.ua/img/cms/articles/howto/howtos_orangepipc_install_linux_from_windows-1.png\" style=\"height:428px; width:495px\" /></p>\r\n\r\n<p>Процесс записи выглядит следующим образом, длительность зависит от скорости карты памяти, в среднем этот процесс длится 5-7 минут. По окончанию записи Вы получите сообщение &quot;Write Successful&quot;.</p>\r\n\r\n<p><img alt=\"\" src=\"https://miniboard.com.ua/img/cms/articles/howto/howtos_orangepipc_install_linux_from_windows-2.png\" style=\"height:222px; width:470px\" /></p>\r\n\r\n<h3>Установка образа Linux из Mac OS</h3>\r\n\r\n<p>Запись образа из Mac OS будет выполнятся только при помощи встроенных системных утилит.</p>\r\n\r\n<ul>\r\n	<li>Скачайте и распакуйте образ ОС и подключите карту памяти к Вашему компьютеру посредством кард-ридера.</li>\r\n	<li>Определите путь в системе к карте памяти при помощи команды&nbsp;<strong>diskutil list</strong>, именно путь к диску, а не его раздел (/dev/disk2 но не /dev/disk2p1). На тестовом стенде это выглядит следующим образом\r\n	<pre>\r\nMacBook-Air:~ username$ diskutil list\r\n/dev/disk0 (internal, physical):\r\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\r\n   0:      GUID_partition_scheme                        *256.1 GB   disk0\r\n   1:                        EFI                         209.7 MB   disk0s1\r\n   2:                  Apple_HFS MACOS                   255.8 GB   disk0s2\r\n/dev/disk2 (external, physical):\r\n   #:                       TYPE NAME                    SIZE       IDENTIFIER\r\n   0:     FDisk_partition_scheme                        *7.7 GB     disk2\r\n   1:                      Linux                         2.8 GB     disk2s1</pre>\r\n	</li>\r\n	<li>Путь к диску определен, а именно /dev/<strong>disk2</strong>, теперь нужно его размонтировать командой&nbsp;<strong>diskutil unmountDisk /dev/disk2</strong>.\r\n	<pre>\r\nMacBook-Air:~ username$ diskutil unmountDisk /dev/disk2\r\nUnmount of all volumes on disk2 was successful</pre>\r\n	</li>\r\n	<li>Приступаем непосредственно к записи образа на microSD карту. Для безопасности записи путь к диску немного видоизменяется, с /dev/disk2 на /dev/<strong>r</strong>disk2, что означает &quot;removable&quot;, утилита&nbsp;проведет дополнительную проверку на то, что запись происходит на съемный носитель, а не локальный диск.<br />\r\n	if= - Путь с образу ОС. То есть&nbsp;&quot;то, что будем копировать&quot;.<br />\r\n	of= - Путь к диску, место назначения. То есть - &quot;то, куда будем копировать&quot;.\r\n	<pre>\r\nMacBook-Air:~ username$ sudo dd bs=1m if=~/Desktop/Armbian_5.14_Orangepipc.img of=/dev/rdisk2 \r\n</pre>\r\n	</li>\r\n	<li>Запись будет происходить без вывода каких-либо уведомлений около 5-7 минут, длительность зависит от скорости карты памяти. Для того, чтобы в процессе записи посмотреть текущее состояние - вы можете воспользоваться сочетанием клавиш CTRL+T. По окончанию записи образа вы увидите следующее сообщение. Запись выполнена. Можете пробовать запускать Orange Pi с картой памяти.\r\n	<pre>\r\n2676+0 records in\r\n2676+0 records out\r\n2805989376 bytes transferred in 216.560596 secs (12957063 bytes/sec)</pre>\r\n	</li>\r\n</ul>\r\n\r\n<p>Проблемы</p>\r\n\r\n<ul>\r\n	<li>Ошибка&nbsp;dd: invalid number &#39;1m&#39; - замените bs=1m на bs=1M в команде записи.</li>\r\n	<li>Если команда записи все еще возвращает ошибку - попробуйте записывать напрямую в карту памяти, без /dev/<strong>r</strong>disk2, просто в /dev/disk2</li>\r\n</ul>\r\n\r\n<h3>Установка образа Linux из Linux</h3>\r\n\r\n<p>Перед началом скачайте предпочитаемый образ ОС и&nbsp;распакуйте его из архива в удобное для Вас место (в примере этот файл будет на рабочем столе), а также подключите карту памяти microSD в кард-ридер компьютера.</p>\r\n\r\n<ul>\r\n	<li>Нужно определить системный путь к карте памяти, выполните команду&nbsp;<strong>df -h</strong>. В левой колонке будут перечислены все диски примонтированные в данный момент, карта памяти будет иметь название похожее на одно из следующих<strong>&nbsp;/dev/mmcblk0</strong>p1 или&nbsp;<strong>/dev/sdс</strong>1. p1 или 1 это номер раздела на диске, а нам нужен сам диск, потому используем /dev/mmcblk0 или /dev/sdc</li>\r\n	<li>Отмонтируйте все разделы&nbsp;карты памяти примонтированные в систему автоматически. В нашем случае только один раздел p1\r\n	<pre>\r\nsudo umount&nbsp;/dev/mmcblk0p1</pre>\r\n	</li>\r\n	<li>Приступаем к записи.&nbsp;<br />\r\n	if= - Путь с образу ОС. То есть&nbsp;&quot;то, что будем копировать&quot;.<br />\r\n	of= - Путь к диску, место назначения. То есть - &quot;то, куда будем копировать&quot;.<br />\r\n	bs=4M - Размер блока данных (чем больше - тем быстрее запись). При ошибках записи понижайте это значение до 1M.\r\n	<pre>\r\nusername$ sudo dd bs=4M if=~/Desktop/Armbian_5.14_Orangepipc.img of=/dev/mmcblk0\r\n</pre>\r\n	</li>\r\n	<li>Выполните команду&nbsp;<strong>sync</strong>&nbsp;чтобы все данные из кэша были окончательно записаны на диск.</li>\r\n</ul>\r\n\r\n<h3>Установка образа Linux в eMMC (NAND)</h3>\r\n\r\n<p>Образы ОС Linux для Orange Pi построены таким образом, что они не могут быть записаны напрямую во внутреннюю память устройства (NAND), потому для установки ОС на eMMC чип придется сначала установить на карту памяти, запустить плату с microSD карты и встроенными в сборку ОС средствами перенести систему во внутреннюю память платы. Эта инструкция применима с платами Orange Pi Plus, Orange Pi Plus 2 и Orange Pi PC Plus.</p>\r\n\r\n<p>В разных сборках ОС свои скрипты для переноса ОС во внутреннюю память, здесь мы упомянем все известные нам ОС и как их перенести в NAND.</p>\r\n\r\n<p>Armbian</p>\r\n\r\n<p>В ОС Armbian есть встроенная утилита (скрипт) nand-sata-install, при выполнении данной команды запустится интуитивный мастер переноса ОС во внутреннюю память устройства или подключенный SATA диск.</p>\r\n\r\n<p>Сборки&nbsp;от loboris</p>\r\n\r\n<ul>\r\n	<li>Установите ОС на карту памяти по инструкциям выше и запустите свой Orange Pi</li>\r\n	<li>Выполните команду&nbsp;\r\n	<pre>\r\nsudo install_to_emmc</pre>\r\n	</li>\r\n	<li>По окончанию процесса отключите питание и извлеките карту памяти из платы.</li>\r\n	<li>Включите питание. Загрузка начнется из внутренней памяти платы.</li>\r\n</ul>\r\n\r\n<p>Обратите внимание, если вы снова загрузите плату с картой памяти на которой записана рабочая ОС, загрузка будет произведена с карты памяти, так как она имеет высший приоритет над встроенной памятью, отформатируйте карту памяти перед использованием в качестве дополнительного хранилища.</p>\r\n\r\n<p>Вы можете использовать файловую систему btrfs со сжатием &quot;compress=lzo&quot; что поможет сохранить до 40% дискового пространства. Для этого - переносите ОС такой командой</p>\r\n\r\n<pre>\r\nsudo install_to_emmc btrfs</pre>\r\n\r\n<p>Перенос ОС из встроенной eMMC на microSD карту</p>\r\n\r\n<ul>\r\n	<li>Запустите плату без подключенной microSD карты.</li>\r\n	<li>После загрузки подключите карту памяти в слот</li>\r\n	<li>Выполните команду\r\n	<pre>\r\nsudo install_to_sdcard [btrfs]</pre>\r\n	</li>\r\n	<li>Готово. Теперь у Вас 2 независимые копии ОС, во внутренней памяти и на microSD карте. microSD карту Вы можете запустить на любом другом Orange Pi.</li>\r\n</ul>\r\n\r\n<p><strong>Установка на USB флешку</strong></p>\r\n\r\n<p>Перенос и загрузка системы может&nbsp;осуществлятся&nbsp;так же с USB флешкой. Для этого в сборках ОС от loboris присутствует скрипт&nbsp;<strong>install_to_usb</strong>.</p>\r\n\r\n<ul>\r\n	<li>Для запуска процесса выполните команду\r\n	<pre>\r\nsudo install_to_usb /dev/sdXn [btrfs]|[noformat]</pre>\r\n	<br />\r\n	<strong>/dev/sdXn</strong>&nbsp;- Путь к USB флешке, можно посмотреть командой&nbsp;<strong>df -h</strong><br />\r\n	<strong>btrfs</strong>&nbsp;- Если добавить этот параметр (не обязательный) флешка будет отформатирована в btrfs вместо ext4<br />\r\n	<strong>noformat</strong>&nbsp;- При использовании данного параметра - USB флешка не будет отформатирована. Данные будут объединены. Используется для обновления резервной копии системы на USB диске.</li>\r\n	<li>По окончанию процесса копирования - перезагрузите плату, загрузка начнется с USB флешки.</li>\r\n</ul>\r\n\r\n<p>Более детальные инструкции по этому процессу описаны в теме форума &quot;<a href=\"http://piboard.io/topic/8/%D0%BF%D0%B5%D1%80%D0%B5%D0%BD%D0%BE%D1%81-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B-orange-pi-%D0%BD%D0%B0-usb-%D1%84%D0%BB%D0%B5%D1%88%D0%BA%D1%83\">Перенос системы Orange Pi на USB флешку</a>&quot;.</p>', '2018-11-22 06:36:27', '2018-11-22 06:39:31');

-- --------------------------------------------------------

--
-- Структура таблицы `users`
--

CREATE TABLE `users` (
  `id` int(10) UNSIGNED NOT NULL,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `email_verified_at` timestamp NULL DEFAULT NULL,
  `password` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `remember_token` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

--
-- Дамп данных таблицы `users`
--

INSERT INTO `users` (`id`, `name`, `email`, `email_verified_at`, `password`, `remember_token`, `created_at`, `updated_at`) VALUES
(1, 'adm', 'adm@mail.ru', NULL, '$2y$10$cTbywPmGFZuaLrLznWAagOvK.YPIQvjpNrthL8OuRSZnJWpV3peHK', 'CothXklhUaJgS86MlsAz9dpkKdUXRkNoPSrCsGI2jZ78vS3BKXctk7uWuvwd', '2018-11-17 15:06:38', '2018-11-17 15:06:38');

--
-- Индексы сохранённых таблиц
--

--
-- Индексы таблицы `categories`
--
ALTER TABLE `categories`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `comments`
--
ALTER TABLE `comments`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `migrations`
--
ALTER TABLE `migrations`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `password_resets`
--
ALTER TABLE `password_resets`
  ADD KEY `password_resets_email_index` (`email`);

--
-- Индексы таблицы `posts`
--
ALTER TABLE `posts`
  ADD PRIMARY KEY (`id`);

--
-- Индексы таблицы `users`
--
ALTER TABLE `users`
  ADD PRIMARY KEY (`id`),
  ADD UNIQUE KEY `users_email_unique` (`email`);

--
-- AUTO_INCREMENT для сохранённых таблиц
--

--
-- AUTO_INCREMENT для таблицы `categories`
--
ALTER TABLE `categories`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;

--
-- AUTO_INCREMENT для таблицы `comments`
--
ALTER TABLE `comments`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;

--
-- AUTO_INCREMENT для таблицы `migrations`
--
ALTER TABLE `migrations`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;

--
-- AUTO_INCREMENT для таблицы `posts`
--
ALTER TABLE `posts`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=8;

--
-- AUTO_INCREMENT для таблицы `users`
--
ALTER TABLE `users`
  MODIFY `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;
COMMIT;

/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
